/**
 * Model File Generator - Creates fully isolated model files
 * Run this to generate all remaining model files from the database
 */

import { supabase } from "@/integrations/supabase/client";

interface AIModel {
  record_id: string;
  id: string;
  model_name: string;
  provider: string;
  content_type: string;
  groups: string[];
  input_schema: any;
  base_token_cost: number;
  cost_multipliers: any;
  api_endpoint: string | null;
  payload_structure: string;
  max_images: number | null;
  default_outputs: number | null;
  estimated_time_seconds: number | null;
}

function sanitizeFileName(name: string): string {
  return name.replace(/[^a-zA-Z0-9_-]/g, "_").replace(/_{2,}/g, "_").replace(/^_|_$/g, "");
}

function extractPrimaryGroup(model: AIModel): string {
  if (Array.isArray(model.groups) && model.groups.length > 0) {
    return model.groups[0];
  }
  return "uncategorized";
}

export function generateModelFileContent(model: AIModel): string {
  const group = extractPrimaryGroup(model);
  const schemaStr = JSON.stringify(model.input_schema, null, 2);
  const costMultipliersStr = JSON.stringify(model.cost_multipliers || {}, null, 2);
  
  return `/**
 * üîí LOCKED MODEL: ${model.model_name}
 * 
 * Group: ${group}
 * Provider: ${model.provider}
 * Content Type: ${model.content_type}
 * 
 * ‚ö†Ô∏è DO NOT EDIT THIS FILE MANUALLY
 * This file is the single source of truth for this model
 */

import type { ExecuteGenerationParams } from "@/lib/generation/executeGeneration";
import { supabase } from "@/integrations/supabase/client";

// MODEL CONFIGURATION
export const MODEL_CONFIG = {
  modelId: "${model.id}",
  recordId: "${model.record_id}",
  modelName: "${model.model_name}",
  provider: "${model.provider}",
  contentType: "${model.content_type}",
  baseCreditCost: ${model.base_token_cost},
  estimatedTimeSeconds: ${model.estimated_time_seconds || 60},
  costMultipliers: ${costMultipliersStr},
  apiEndpoint: ${model.api_endpoint ? `"${model.api_endpoint}"` : "null"},
  payloadStructure: "${model.payload_structure || "wrapper"}",
  maxImages: ${model.max_images ?? "null"},
  defaultOutputs: ${model.default_outputs || 1},
} as const;

// FROZEN SCHEMA
export const SCHEMA = ${schemaStr};

// VALIDATION
export function validate(inputs: Record<string, any>): { valid: boolean; error?: string } {
  const required = (SCHEMA as any).required || [];
  for (const field of required) {
    if (!inputs[field]) return { valid: false, error: \`\${field} is required\` };
  }
  if (inputs.prompt && inputs.prompt.length < 3) {
    return { valid: false, error: "Prompt must be at least 3 characters" };
  }
  return { valid: true };
}

// PAYLOAD PREPARATION
export function preparePayload(inputs: Record<string, any>): Record<string, any> {
  const payload: Record<string, any> = {};
  Object.entries(inputs).forEach(([key, value]) => {
    if (value !== undefined && value !== null) {
      payload[key] = value;
    }
  });
  return payload;
}

// COST CALCULATION
export function calculateCost(inputs: Record<string, any>): number {
  let cost = MODEL_CONFIG.baseCreditCost;
  if (MODEL_CONFIG.costMultipliers) {
    Object.entries(MODEL_CONFIG.costMultipliers).forEach(([param, multipliers]: [string, any]) => {
      if (inputs[param] && typeof multipliers === "object") {
        const multiplier = multipliers[String(inputs[param])];
        if (multiplier) cost *= multiplier;
      }
    });
  }
  return Math.round(cost * 100) / 100;
}

// EXECUTION
export async function execute(params: ExecuteGenerationParams): Promise<string> {
  const { prompt, modelParameters, userId } = params;
  
  const validation = validate({ ...modelParameters, prompt });
  if (!validation.valid) throw new Error(validation.error);
  
  const cost = calculateCost({ ...modelParameters, prompt });
  
  const { data: generation, error: genError } = await supabase
    .from('generations')
    .insert({
      user_id: userId,
      model_id: MODEL_CONFIG.modelId,
      model_record_id: MODEL_CONFIG.recordId,
      prompt,
      type: MODEL_CONFIG.contentType,
      status: 'processing',
      tokens_used: cost,
      settings: modelParameters
    })
    .select()
    .single();

  if (genError || !generation) throw new Error(\`Failed to create generation: \${genError?.message}\`);

  const payload = MODEL_CONFIG.payloadStructure === "wrapper"
    ? { task: MODEL_CONFIG.modelId.split('/')[1], input: preparePayload({ ...modelParameters, prompt }) }
    : preparePayload({ ...modelParameters, prompt });

  try {
    const apiKey = await getProviderApiKey(MODEL_CONFIG.provider);
    const baseUrl = MODEL_CONFIG.provider === "kie_ai" ? "https://api.klingai.com" : "";
    
    const response = await fetch(\`\${baseUrl}\${MODEL_CONFIG.apiEndpoint}\`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': \`Bearer \${apiKey}\`
      },
      body: JSON.stringify(payload)
    });

    if (!response.ok) throw new Error(\`API call failed: \${response.statusText}\`);
    const result = await response.json();
    
    await supabase.from('generations').update({
      provider_task_id: result.taskId || result.id,
      provider_request: payload,
      provider_response: result
    }).eq('id', generation.id);

    params.startPolling(generation.id);
    return generation.id;
  } catch (error) {
    await supabase.from('generations').update({ status: 'failed' }).eq('id', generation.id);
    throw error;
  }
}

async function getProviderApiKey(provider: string, modelId: string, recordId: string, use_api_key: string): Promise<string> {
  const { data, error } = await supabase.functions.invoke('get-api-key', {
    body: { provider, modelId, recordId, use_api_key }
  });
  if (error || !data?.apiKey) throw new Error('Failed to get API key');
  return data.apiKey;
}
`;
}

export async function generateAllModelFiles() {
  console.log("Fetching all models from database...");
  
  const { data: models, error } = await supabase
    .from('ai_models')
    .select('*')
    .order('provider', { ascending: true })
    .order('model_name', { ascending: true });

  if (error || !models) {
    console.error("Failed to fetch models:", error);
    return;
  }

  console.log(`Found ${models.length} models to generate`);

  for (const model of models) {
    const group = extractPrimaryGroup(model as AIModel);
    const fileName = sanitizeFileName(model.model_name);
    const filePath = `src/lib/models/locked/${group}/${fileName}.ts`;
    const content = generateModelFileContent(model as AIModel);
    
    console.log(`Generated: ${filePath}`);
    console.log("Content preview:", content.substring(0, 200));
    console.log("---");
  }

  console.log(`\nGenerated ${models.length} model files!`);
  console.log("\nNext step: Copy the generated content to create each file");
}
