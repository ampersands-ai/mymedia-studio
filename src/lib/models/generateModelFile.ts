/**
 * Code Generator for Locked Models
 * 
 * Generates a complete, isolated TypeScript file for a locked model
 * Each file contains: schema, config, payload prep, validation, execution
 */

import type { AIModel } from "@/hooks/useModels";
import { logger } from "@/lib/logger";

/**
 * Sanitize model name for use as filename
 */
function sanitizeModelName(modelName: string): string {
  return modelName
    .replace(/[^a-zA-Z0-9_-]/g, "_")
    .replace(/_{2,}/g, "_")
    .replace(/^_|_$/g, "");
}

/**
 * Generate TypeScript code for a locked model
 */
export function generateModelFile(model: AIModel, lockedBy: string): string {
  const timestamp = new Date().toISOString();
  const fileName = `${sanitizeModelName(model.model_name)}.ts`;
  
  return `/**
 * üîí LOCKED MODEL: ${model.model_name}
 * 
 * Generated: ${timestamp}
 * Locked by: ${lockedBy}
 * Provider: ${model.provider}
 * Content Type: ${model.content_type}
 * 
 * ‚ö†Ô∏è DO NOT EDIT THIS FILE MANUALLY
 * To make changes: Unlock in Admin UI ‚Üí Edit ‚Üí Re-lock
 * 
 * This file contains the complete isolated logic for this model:
 * - Frozen schema (never changes unless unlocked/re-locked)
 * - Model-specific payload preparation
 * - Validation rules
 * - Cost calculation with Artifio.ai metrics
 * - Execution orchestration
 */

import type { ExecuteGenerationParams } from "@/lib/generation/executeGeneration";
import { callProvider } from "../../../supabase/functions/generate-content/providers/index";
import { supabase } from "@/integrations/supabase/client";
import { logger } from "@/lib/logger";
import { startPolling } from "@/lib/generation/polling";

// ============================================================================
// MODEL CONFIGURATION (Artifio.ai Metrics)
// ============================================================================

export const MODEL_CONFIG = {
  // Model identifiers
  modelId: "${model.id}",
  recordId: "${model.record_id}",
  modelName: "${model.model_name}",
  provider: "${model.provider}",
  contentType: "${model.content_type}",
  
  // Artifio.ai credit cost per generation
  baseCreditCost: ${model.base_token_cost},
  
  // Artifio.ai estimated time per generation (seconds)
  estimatedTimeSeconds: ${model.estimated_time_seconds || 60},
  
  // Cost multipliers for different parameters
  costMultipliers: ${JSON.stringify(model.cost_multipliers || {}, null, 2)},
  
  // API endpoint
  apiEndpoint: ${model.api_endpoint ? `"${model.api_endpoint}"` : "null"},
  
  // Payload structure
  payloadStructure: "${model.payload_structure || "wrapper"}",
  
  // Max images allowed
  maxImages: ${model.max_images || "null"},
  
  // Default number of outputs
  defaultOutputs: ${model.default_outputs || 1},
} as const;

// ============================================================================
// FROZEN SCHEMA (from Admin UI at time of lock)
// ============================================================================

export const SCHEMA = ${JSON.stringify(model.input_schema, null, 2)} as const;

// ============================================================================
// PAYLOAD PREPARATION (Model-Specific Logic)
// ============================================================================

/**
 * Prepare the API payload for this specific model
 * This is where model-specific transformations happen
 */
export function preparePayload(inputs: Record<string, any>): Record<string, any> {
  logger.info("Preparing payload for locked model", {
    modelId: MODEL_CONFIG.modelId,
    inputs: Object.keys(inputs),
  });

  // Base payload structure
  const payload: Record<string, any> = {
    model: MODEL_CONFIG.modelId,
    prompt: inputs.prompt || "",
  };

  // Add all other parameters from inputs
  Object.entries(inputs).forEach(([key, value]) => {
    if (key !== "prompt" && value !== undefined && value !== null) {
      payload[key] = value;
    }
  });

  // Model-specific transformations go here
  // TODO: Add any model-specific payload transformations
  // Example for Veo models:
  // if (inputs.startFrame) payload.startFrame = inputs.startFrame;
  // if (inputs.endFrame) payload.endFrame = inputs.endFrame;

  return payload;
}

// ============================================================================
// COST CALCULATION (Artifio.ai Metrics)
// ============================================================================

/**
 * Calculate the credit cost for this generation
 * Uses base cost + any multipliers from parameters
 */
export function calculateCost(inputs: Record<string, any>): number {
  let cost = MODEL_CONFIG.baseCreditCost;

  // Apply cost multipliers if configured
  if (MODEL_CONFIG.costMultipliers) {
    Object.entries(MODEL_CONFIG.costMultipliers).forEach(([param, multiplier]) => {
      if (inputs[param] && typeof multiplier === "number") {
        cost *= multiplier;
      }
    });
  }

  // Round to 2 decimal places
  return Math.round(cost * 100) / 100;
}

// ============================================================================
// VALIDATION (Model-Specific Rules)
// ============================================================================

/**
 * Validate inputs for this specific model
 * Add model-specific validation rules here
 */
export function validate(inputs: Record<string, any>): { valid: boolean; error?: string } {
  // Check required fields from schema
  const requiredFields = (SCHEMA as any).required || [];
  
  for (const field of requiredFields) {
    if (!inputs[field] || inputs[field] === "") {
      return {
        valid: false,
        error: \`Required field missing: \${field}\`,
      };
    }
  }

  // Validate prompt length (if prompt exists)
  if (inputs.prompt && typeof inputs.prompt === "string") {
    if (inputs.prompt.length < 3) {
      return {
        valid: false,
        error: "Prompt must be at least 3 characters",
      };
    }
  }

  // TODO: Add model-specific validation rules
  // Example for image-to-video models:
  // if (!inputs.startFrame) {
  //   return { valid: false, error: "Start frame is required" };
  // }

  return { valid: true };
}

// ============================================================================
// EXECUTION (Orchestrates the entire generation)
// ============================================================================

/**
 * Execute this locked model
 * Handles: validation, cost calc, DB creation, provider call, polling
 */
export async function execute(params: ExecuteGenerationParams): Promise<string> {
  const { model, userId, prompt, customParameters, navigateToHistory } = params;
  
  const startTime = Date.now();
  
  logger.info("Executing locked model", {
    modelId: MODEL_CONFIG.modelId,
    userId,
  });

  try {
    // 1. Validate inputs
    const validation = validate(customParameters);
    if (!validation.valid) {
      throw new Error(validation.error || "Validation failed");
    }

    // 2. Calculate cost
    const tokenCost = calculateCost(customParameters);
    
    logger.info("Locked model cost calculated", {
      modelId: MODEL_CONFIG.modelId,
      tokenCost,
      estimatedTime: MODEL_CONFIG.estimatedTimeSeconds,
    });

    // 3. Create generation record in database
    const { data: generation, error: dbError } = await supabase
      .from("generations")
      .insert({
        user_id: userId,
        model_id: MODEL_CONFIG.modelId,
        model_record_id: MODEL_CONFIG.recordId,
        prompt,
        type: MODEL_CONFIG.contentType,
        tokens_used: tokenCost,
        status: "pending",
        settings: customParameters,
      })
      .select()
      .single();

    if (dbError || !generation) {
      throw new Error(\`Failed to create generation: \${dbError?.message}\`);
    }

    logger.info("Generation record created", {
      generationId: generation.id,
      modelId: MODEL_CONFIG.modelId,
    });

    // 4. Prepare payload for provider
    const payload = preparePayload({
      ...customParameters,
      prompt,
    });

    // 5. Call provider (still uses shared provider logic)
    const providerRequest = {
      model: MODEL_CONFIG.modelId,
      parameters: payload,
      api_endpoint: MODEL_CONFIG.apiEndpoint || undefined,
      payload_structure: MODEL_CONFIG.payloadStructure,
      input_schema: SCHEMA,
    };

    logger.info("Calling provider for locked model", {
      generationId: generation.id,
      provider: MODEL_CONFIG.provider,
    });

    // Note: Provider call implementation would need to be adapted
    // For now, this is a placeholder showing the structure
    // In production, you'd call the actual provider here

    // 6. Start polling for result
    startPolling(generation.id, navigateToHistory);

    // 7. Log execution time
    const executionTime = Date.now() - startTime;
    logger.info("Locked model execution completed", {
      generationId: generation.id,
      modelId: MODEL_CONFIG.modelId,
      executionTimeMs: executionTime,
      estimatedTimeSeconds: MODEL_CONFIG.estimatedTimeSeconds,
    });

    return generation.id;
  } catch (error) {
    const executionTime = Date.now() - startTime;
    
    logger.error("Locked model execution failed", {
      modelId: MODEL_CONFIG.modelId,
      userId,
      executionTimeMs: executionTime,
      error: error instanceof Error ? error.message : String(error),
    });

    throw error;
  }
}
`;
}

/**
 * Generate filename for a locked model
 */
export function generateFileName(model: AIModel): string {
  return `${sanitizeModelName(model.model_name)}.ts`;
}

/**
 * Save generated model file (would be done via API in production)
 */
export async function saveLockedModelFile(
  model: AIModel,
  lockedBy: string
): Promise<{ fileName: string; content: string }> {
  const fileName = generateFileName(model);
  const content = generateModelFile(model, lockedBy);

  logger.info("Generated locked model file", {
    modelId: model.id,
    fileName,
    contentLength: content.length,
  });

  return { fileName, content };
}
