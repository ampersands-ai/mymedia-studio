import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Generate a unique random ID for JSON2Video project identifier
const generateUniqueRenderJobId = (): string => {
  const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
  return Array.from({ length: 8 }, () => 
    chars[Math.floor(Math.random() * chars.length)]
  ).join('');
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: req.headers.get('Authorization')! },
        },
      }
    );

    const { data: { user } } = await supabaseClient.auth.getUser();
    if (!user) {
      throw new Error('Unauthorized');
    }

    const { storyboardId } = await req.json();

    // Generate unique render job ID for this request
    const uniqueRenderJobId = generateUniqueRenderJobId();
    console.log(`[render-storyboard-video] Generated unique render job ID: ${uniqueRenderJobId}`);

    // Fetch storyboard first to calculate cost and get initial estimate
    const { data: storyboard, error: storyboardError } = await supabaseClient
      .from('storyboards')
      .select('*, intro_image_preview_url, intro_voiceover_text, estimated_render_cost')
      .eq('id', storyboardId)
      .eq('user_id', user.id)
      .single();

    if (storyboardError || !storyboard) {
      throw new Error('Storyboard not found or unauthorized');
    }

    // Fetch scenes to calculate total duration
    const { data: scenes, error: scenesError } = await supabaseClient
      .from('storyboard_scenes')
      .select('id, order_number, voice_over_text, image_prompt, image_preview_url')
      .eq('storyboard_id', storyboardId)
      .order('order_number', { ascending: true });

    if (scenesError || !scenes || scenes.length === 0) {
      throw new Error('No scenes found');
    }

    // Validate all scenes have required data
    for (const scene of scenes) {
      if (!scene.voice_over_text || !scene.image_prompt) {
        throw new Error('All scenes must have voiceover and image prompt');
      }
    }

    // Determine which template to use based on image generation method
    const hasIntroPreview = !!storyboard.intro_image_preview_url;
    const scenesWithPreview = scenes.filter(s => !!s.image_preview_url);
    const allScenesHavePreview = scenesWithPreview.length === scenes.length;
    const noScenesHavePreview = scenesWithPreview.length === 0;

    let templateId: string;
    let templateType: 'all-pregenerated' | 'mixed' | 'all-ai-generated';

    if (hasIntroPreview && allScenesHavePreview) {
      // All images are pre-generated
      templateId = 'mG1o3jStlfepwwOj8a2H';
      templateType = 'all-pregenerated';
      console.log('[render-storyboard-video] Using all-pregenerated template');
    } else if (noScenesHavePreview && !hasIntroPreview) {
      // All images will be AI-generated by JSON2Video
      templateId = 'hae1en4rQdJHFgFS3545';
      templateType = 'all-ai-generated';
      console.log('[render-storyboard-video] Using all-ai-generated template');
    } else {
      // Mixed: some scenes have previews, some don't
      templateId = 'DcARTfg9eDbETcccFM7m';
      templateType = 'mixed';
      console.log(`[render-storyboard-video] Using mixed template (intro: ${hasIntroPreview ? 'preview' : 'prompt'}, scenes: ${scenesWithPreview.length}/${scenes.length} with previews)`);
    }

    console.log(`[render-storyboard-video] Template selection summary:
  - Template: ${templateId} (${templateType})
  - Intro: ${hasIntroPreview ? 'Pre-generated' : 'AI prompt'}
  - Scenes: ${scenesWithPreview.length}/${scenes.length} pre-generated`);

    // Calculate estimated duration based on voice-over text (for logging purposes)
    // Note: Actual pricing is now based on character count changes
    const countWords = (text: string) => text.trim().split(/\s+/).filter(w => w.length > 0).length;
    
    const introWords = storyboard.intro_voiceover_text ? countWords(storyboard.intro_voiceover_text) : 0;
    const sceneWords = scenes.reduce((sum, scene) => sum + countWords(scene.voice_over_text), 0);
    const totalWords = introWords + sceneWords;
    
    // Estimate duration in seconds (2.5 words per second)
    const estimatedDuration = Math.ceil(totalWords / 2.5);
    
    console.log(`[render-storyboard-video] Estimated duration: ${estimatedDuration}s (${totalWords} words)`);

    // Get initial estimate and check user credit balance
    const initialEstimate = storyboard.estimated_render_cost || (storyboard.duration * 0.25);
    
    const { data: subscription, error: subError } = await supabaseClient
      .from('user_subscriptions')
      .select('tokens_remaining')
      .eq('user_id', user.id)
      .single();

    if (subError || !subscription) {
      throw new Error('Could not fetch user subscription');
    }

    // Never charge more than initial estimate - lock in the original price
    // Calculate pricing based on character changes
    const countChars = (text: string) => text?.trim().length || 0;
    
    // Calculate current total character count
    const introChars = countChars(storyboard.intro_voiceover_text || '');
    const sceneChars = scenes.reduce((sum, scene) => sum + countChars(scene.voice_over_text), 0);
    const currentTotalChars = introChars + sceneChars;
    
    // Get original character count
    const originalChars = storyboard.original_character_count || currentTotalChars;
    
    // Calculate character difference
    const charDifference = currentTotalChars - originalChars;
    
    console.log(`[render-storyboard-video] Character count - Original: ${originalChars}, Current: ${currentTotalChars}, Difference: ${charDifference}`);
    
    // Calculate actual cost based on character changes
    let actualCost = initialEstimate;
    
    if (charDifference >= 100) {
      // Script increased: add 0.25 credits per 100 chars
      const additionalChunks = Math.floor(charDifference / 100);
      actualCost += additionalChunks * 0.25;
      console.log(`[render-storyboard-video] Script increased by ${charDifference} chars (${additionalChunks} chunks), adding ${(additionalChunks * 0.25).toFixed(2)} credits`);
    } else if (charDifference <= -100) {
      // Script decreased: reduce cost proportionally
      const reducedChunks = Math.floor(Math.abs(charDifference) / 100);
      actualCost -= reducedChunks * 0.25;
      actualCost = Math.max(0, actualCost);
      console.log(`[render-storyboard-video] Script decreased by ${Math.abs(charDifference)} chars (${reducedChunks} chunks), reducing ${(reducedChunks * 0.25).toFixed(2)} credits`);
    }
    
    console.log(`[render-storyboard-video] Initial estimate: ${initialEstimate} credits, Actual cost: ${actualCost.toFixed(2)} credits`);
    
    // If actual is lower, refund the difference
    // Note: User was already charged initialEstimate when storyboard was created
    
    if (actualCost < initialEstimate) {
      // Refund the difference
      const refundAmount = initialEstimate - actualCost;
      console.log(`[render-storyboard-video] Refunding ${refundAmount.toFixed(2)} credits`);
      
      const { error: refundError } = await supabaseClient.rpc('increment_tokens', {
        user_id_param: user.id,
        amount: refundAmount
      });
      
      if (refundError) {
        console.error('[render-storyboard-video] Failed to refund credits:', refundError);
        // Don't throw - continue with render even if refund fails
      }
    } else if (actualCost > initialEstimate) {
      // Script increased - charge the difference
      const additionalCharge = actualCost - initialEstimate;
      
      // Check if user has enough credits
      if (subscription.tokens_remaining < additionalCharge) {
        return new Response(
          JSON.stringify({ error: `Insufficient credits. Script changes require ${additionalCharge.toFixed(2)} additional credits.` }),
          { status: 402, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
        );
      }
      
      console.log(`[render-storyboard-video] Charging ${additionalCharge.toFixed(2)} additional credits for script increase`);
      
      const { error: chargeError } = await supabaseClient.rpc('increment_tokens', {
        user_id_param: user.id,
        amount: -additionalCharge
      });
      
      if (chargeError) {
        console.error('[render-storyboard-video] Failed to charge additional credits:', chargeError);
        throw new Error('Failed to charge additional credits');
      }
    }
    
    // Update the actual cost in the storyboard
    const { error: updateCostError } = await supabaseClient
      .from('storyboards')
      .update({ estimated_render_cost: actualCost })
      .eq('id', storyboardId);


    if (updateCostError) {
      console.error('[render-storyboard-video] Failed to update actual cost:', updateCostError);
    }

    // Build JSON2Video payload
    const json2videoApiKey = Deno.env.get('JSON2VIDEO_API_KEY');
    if (!json2videoApiKey) {
      throw new Error('JSON2VIDEO_API_KEY not configured');
    }

    const webhookUrl = `${Deno.env.get('SUPABASE_URL')}/functions/v1/json2video-webhook`;
    
    // Build variables based on template type
    const variables: Record<string, any> = {
      voiceModel: storyboard.voice_model || 'azure',
      imageModel: storyboard.image_model || 'freepik-classic',
      subtitlesModel: storyboard.subtitles_model || 'default',
      fontFamily: storyboard.subtitle_settings?.fontFamily || 'Oswald Bold',
      voiceID: storyboard.voice_id,
      introText: storyboard.intro_voiceover_text,
      
      // json2video Core Subtitle Parameters
      subtitleStyle: storyboard.subtitle_settings?.style || 'boxed-word',
      subtitleAllCaps: storyboard.subtitle_settings?.allCaps ?? false,
      subtitleBoxColor: storyboard.subtitle_settings?.boxColor || '#000000',
      subtitleLineColor: storyboard.subtitle_settings?.lineColor || '#FFFFFF',
      subtitleWordColor: storyboard.subtitle_settings?.wordColor || '#FFFF00',
      subtitleMaxWordsPerLine: storyboard.subtitle_settings?.maxWordsPerLine || 4,
      
      // Custom positioning
      subtitleX: storyboard.subtitle_settings?.x || 0,
      subtitleY: storyboard.subtitle_settings?.y || 0,
      
      // Shadow (json2video uses shadowOffset)
      subtitleShadowOffset: storyboard.subtitle_settings?.shadowOffset || 0,
      
      // Advanced features
      subtitleKeywords: storyboard.subtitle_settings?.keywords || [],
      subtitleReplace: storyboard.subtitle_settings?.replace || {},
      subtitleFontUrl: storyboard.subtitle_settings?.fontUrl || '',
      
      // Comprehensive subtitle settings (all parameters)
      subtitleFontSize: storyboard.subtitle_settings?.fontSize || 140,
      subtitleFontColor: storyboard.subtitle_settings?.fontColor || '#FFFFFF',
      subtitleFontWeight: storyboard.subtitle_settings?.fontWeight || 'bold',
      subtitleFontStyle: storyboard.subtitle_settings?.fontStyle || 'normal',
      subtitleTextAlign: storyboard.subtitle_settings?.textAlign || 'center',
      subtitleTextTransform: storyboard.subtitle_settings?.textTransform || 'none',
      subtitleLineHeight: storyboard.subtitle_settings?.lineHeight || 1.2,
      subtitleLetterSpacing: storyboard.subtitle_settings?.letterSpacing || 0,
      
      subtitleBackgroundColor: storyboard.subtitle_settings?.backgroundColor || 'transparent',
      subtitleBackgroundOpacity: storyboard.subtitle_settings?.backgroundOpacity ?? 0.8,
      subtitleBackgroundPadding: storyboard.subtitle_settings?.backgroundPadding || 20,
      subtitleBackgroundRadius: storyboard.subtitle_settings?.backgroundRadius || 10,
      
      subtitleOutlineColor: storyboard.subtitle_settings?.outlineColor || '#000000',
      subtitleOutlineWidth: storyboard.subtitle_settings?.outlineWidth ?? 8,
      
      subtitleShadowColor: storyboard.subtitle_settings?.shadowColor || '#000000',
      subtitleShadowBlur: storyboard.subtitle_settings?.shadowBlur || 10,
      subtitleShadowX: storyboard.subtitle_settings?.shadowX || 2,
      subtitleShadowY: storyboard.subtitle_settings?.shadowY || 2,
      
      subtitleOffsetX: storyboard.subtitle_settings?.offsetX || 0,
      subtitleOffsetY: storyboard.subtitle_settings?.offsetY || 0,
      subtitleMaxWidth: storyboard.subtitle_settings?.maxWidth || 800,
      
      subtitleAnimation: storyboard.subtitle_settings?.animation || 'none',
      subtitleAnimationDuration: storyboard.subtitle_settings?.animationDuration || 0.3,
      
      subtitleLanguage: storyboard.subtitle_settings?.language || 'auto',
      
      // Music settings as variables
      musicVolume: storyboard.music_settings?.volume || 0.05,
      musicFadeIn: storyboard.music_settings?.fadeIn || 2,
      musicFadeOut: storyboard.music_settings?.fadeOut || 2,
    };

    // Add intro image based on whether it's pre-generated or AI-generated
    if (storyboard.intro_image_preview_url) {
      variables.introImageUrl = storyboard.intro_image_preview_url;
    } else {
      variables.introImagePrompt = storyboard.intro_image_prompt;
    }

    // Build scenes array with appropriate image properties
    variables.scenes = scenes.map(s => {
      const sceneData: Record<string, any> = {
        voiceOverText: s.voice_over_text,
      };
      
      // Add image URL if available, otherwise use prompt
      if (s.image_preview_url) {
        sceneData.imageUrl = s.image_preview_url;
      } else {
        sceneData.imagePrompt = s.image_prompt;
      }
      
      return sceneData;
    });

    console.log(`[render-storyboard-video] Built variables with keys: ${Object.keys(variables).join(', ')}`);

    const renderPayload = {
      template: templateId,
      variables,
      project: uniqueRenderJobId,
      exports: [
        {
          destinations: [
            {
              type: "webhook",
              endpoint: webhookUrl,
              "content-type": "json"
            }
          ]
        }
      ],
      // Apply customization settings
      ...mapAspectRatio(
        storyboard.aspect_ratio || 'full-hd',
        storyboard.custom_width,
        storyboard.custom_height
      ),
      quality: (['low', 'medium', 'high'].includes(storyboard.video_quality) ? storyboard.video_quality : 'high'),
      cache: storyboard.enable_cache ?? true,
      draft: storyboard.draft_mode ?? false,
    };

    // Helper function to map resolution presets
    function mapAspectRatio(ratio: string, customWidth?: number, customHeight?: number) {
      // For custom resolution, width and height are required
      if (ratio === 'custom') {
        if (!customWidth || !customHeight) {
          throw new Error('Custom resolution requires width and height');
        }
        return {
          resolution: 'custom',
          width: customWidth,
          height: customHeight
        };
      }
      
      // For preset resolutions, only resolution is needed (API sets dimensions)
      // But we include width/height for completeness
      const presetMap: Record<string, { resolution: string; width?: number; height?: number }> = {
        'sd': { resolution: 'sd' },
        'hd': { resolution: 'hd' },
        'full-hd': { resolution: 'full-hd' },
        'squared': { resolution: 'squared' },
        'instagram-story': { resolution: 'instagram-story' },
        'instagram-feed': { resolution: 'instagram-feed' },
        'twitter-landscape': { resolution: 'twitter-landscape' },
        'twitter-portrait': { resolution: 'twitter-portrait' },
      };
      
      return presetMap[ratio] || presetMap['full-hd']; // Default to Full HD
    }

    console.log('[render-storyboard-video] Calling JSON2Video API with payload:', JSON.stringify(renderPayload, null, 2));

    // Call JSON2Video API
    const json2videoResponse = await fetch('https://api.json2video.com/v2/movies', {
      method: 'POST',
      headers: {
        'x-api-key': json2videoApiKey,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(renderPayload)
    });

    if (!json2videoResponse.ok) {
      const errorText = await json2videoResponse.text();
      console.error('[render-storyboard-video] JSON2Video API error:', json2videoResponse.status, errorText);
      
      // Refund initial estimate (actual cost may have been higher due to script changes, but we limit refund to initial)
      await supabaseClient.rpc('increment_tokens', {
        user_id_param: user.id,
        amount: initialEstimate
      });
      
      if (json2videoResponse.status === 429) {
        throw new Error('JSON2Video rate limit exceeded. Please try again later.');
      } else if (json2videoResponse.status === 401 || json2videoResponse.status === 403) {
        throw new Error('JSON2Video API authentication failed. Please contact support.');
      }
      
      throw new Error(`JSON2Video API error: ${json2videoResponse.status}`);
    }

    const json2videoData = await json2videoResponse.json();
    console.log('[render-storyboard-video] JSON2Video response:', json2videoData);

    // ✅ CRITICAL: Use JSON2Video's returned project ID, not our generated one!
    const json2videoProjectId = json2videoData.project;

    if (!json2videoProjectId) {
      console.error('[render-storyboard-video] JSON2Video did not return a project ID!');
      
      // Refund initial estimate (actual cost may have been higher, but we limit refund to initial)
      await supabaseClient.rpc('increment_tokens', {
        user_id_param: user.id,
        amount: initialEstimate
      });
      
      throw new Error('JSON2Video API error: No project ID in response');
    }

    console.log('[render-storyboard-video] JSON2Video assigned project ID:', json2videoProjectId);
    console.log('[render-storyboard-video] Our generated ID was:', uniqueRenderJobId, '(will be replaced)');

    // Update storyboard status with JSON2Video's project ID
    const { error: updateError } = await supabaseClient
      .from('storyboards')
      .update({
        status: 'rendering',
        render_job_id: json2videoProjectId, // ✅ Use THEIR ID, not ours!
        updated_at: new Date().toISOString()
      })
      .eq('id', storyboardId);

    if (updateError) {
      console.error('[render-storyboard-video] Status update error:', updateError);
      // Refund initial estimate (actual cost may have been higher, but we limit refund to initial)
      await supabaseClient.rpc('increment_tokens', {
        user_id_param: user.id,
        amount: initialEstimate
      });
      throw new Error('Failed to update storyboard status');
    }

    return new Response(
      JSON.stringify({
        jobId: json2videoProjectId, // ✅ Return THEIR ID for polling
        estimatedTime: 180, // 3 minutes typical for JSON2Video
        webhookConfigured: true,
        message: 'Video rendering started. You will be notified when complete.'
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );

  } catch (error) {
    console.error('Error:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    return new Response(
      JSON.stringify({ error: errorMessage }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});