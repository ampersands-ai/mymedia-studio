#!/usr/bin/env tsx
/**
 * Generate ALL 60 model files and update registry
 * Run with: npx tsx scripts/generate-all-models.ts
 */

import { createClient } from '@supabase/supabase-js';
import * as fs from 'fs';
import * as path from 'path';

const SUPABASE_URL = process.env.VITE_SUPABASE_URL!;
const SUPABASE_KEY = process.env.VITE_SUPABASE_PUBLISHABLE_KEY!;

const supabase = createClient(SUPABASE_URL, SUPABASE_KEY);

interface AIModel {
  record_id: string;
  id: string;
  model_name: string;
  provider: string;
  content_type: string;
  groups: string[];
  input_schema: any;
  base_token_cost: number;
  cost_multipliers: any;
  api_endpoint: string | null;
  payload_structure: string;
  max_images: number | null;
  default_outputs: number | null;
  estimated_time_seconds: number | null;
}

function sanitizeFileName(name: string): string {
  return name.replace(/[^a-zA-Z0-9_-]/g, "_").replace(/_{2,}/g, "_").replace(/^_|_$/g, "");
}

function extractPrimaryGroup(model: AIModel): string {
  if (Array.isArray(model.groups) && model.groups.length > 0) {
    return model.groups[0];
  }
  return "uncategorized";
}

function generateModelFileContent(model: AIModel): string {
  const group = extractPrimaryGroup(model);
  const schemaStr = JSON.stringify(model.input_schema, null, 2);
  const costMultipliersStr = JSON.stringify(model.cost_multipliers || {}, null, 2);
  
  return `/**
 * üîí LOCKED MODEL: ${model.model_name}
 * 
 * Group: ${group}
 * Provider: ${model.provider}
 * Content Type: ${model.content_type}
 * 
 * ‚ö†Ô∏è DO NOT EDIT THIS FILE MANUALLY
 * This file is the single source of truth for this model
 */

import type { ExecuteGenerationParams } from "@/lib/generation/executeGeneration";
import { supabase } from "@/integrations/supabase/client";

// MODEL CONFIGURATION
export const MODEL_CONFIG = {
  modelId: "${model.id}",
  recordId: "${model.record_id}",
  modelName: "${model.model_name}",
  provider: "${model.provider}",
  contentType: "${model.content_type}",
  baseCreditCost: ${model.base_token_cost},
  estimatedTimeSeconds: ${model.estimated_time_seconds || 60},
  costMultipliers: ${costMultipliersStr},
  apiEndpoint: ${model.api_endpoint ? `"${model.api_endpoint}"` : "null"},
  payloadStructure: "${model.payload_structure || "wrapper"}",
  maxImages: ${model.max_images ?? "null"},
  defaultOutputs: ${model.default_outputs || 1},
} as const;

// FROZEN SCHEMA
export const SCHEMA = ${schemaStr};

// VALIDATION
export function validate(inputs: Record<string, any>): { valid: boolean; error?: string } {
  const required = (SCHEMA as any).required || [];
  for (const field of required) {
    if (!inputs[field]) return { valid: false, error: \`\${field} is required\` };
  }
  if (inputs.prompt && inputs.prompt.length < 3) {
    return { valid: false, error: "Prompt must be at least 3 characters" };
  }
  return { valid: true };
}

// PAYLOAD PREPARATION
export function preparePayload(inputs: Record<string, any>): Record<string, any> {
  const payload: Record<string, any> = {};
  Object.entries(inputs).forEach(([key, value]) => {
    if (value !== undefined && value !== null) {
      payload[key] = value;
    }
  });
  return payload;
}

// COST CALCULATION
export function calculateCost(inputs: Record<string, any>): number {
  let cost = MODEL_CONFIG.baseCreditCost;
  if (MODEL_CONFIG.costMultipliers) {
    Object.entries(MODEL_CONFIG.costMultipliers).forEach(([param, multipliers]: [string, any]) => {
      if (inputs[param] && typeof multipliers === "object") {
        const multiplier = multipliers[String(inputs[param])];
        if (multiplier) cost *= multiplier;
      }
    });
  }
  return Math.round(cost * 100) / 100;
}

// EXECUTION
export async function execute(params: ExecuteGenerationParams): Promise<string> {
  const { prompt, modelParameters, userId } = params;
  
  const validation = validate({ ...modelParameters, prompt });
  if (!validation.valid) throw new Error(validation.error);
  
  const cost = calculateCost({ ...modelParameters, prompt });
  
  const { data: generation, error: genError } = await supabase
    .from('generations')
    .insert({
      user_id: userId,
      model_id: MODEL_CONFIG.modelId,
      model_record_id: MODEL_CONFIG.recordId,
      prompt,
      type: MODEL_CONFIG.contentType,
      status: 'processing',
      tokens_used: cost,
      settings: modelParameters
    })
    .select()
    .single();

  if (genError || !generation) throw new Error(\`Failed to create generation: \${genError?.message}\`);

  const payload = MODEL_CONFIG.payloadStructure === "wrapper"
    ? { task: MODEL_CONFIG.modelId.split('/')[1], input: preparePayload({ ...modelParameters, prompt }) }
    : preparePayload({ ...modelParameters, prompt });

  try {
    const apiKey = await getProviderApiKey(MODEL_CONFIG.provider);
    const baseUrl = MODEL_CONFIG.provider === "kie_ai" ? "https://api.klingai.com" : "";
    
    const response = await fetch(\`\${baseUrl}\${MODEL_CONFIG.apiEndpoint}\`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': \`Bearer \${apiKey}\`
      },
      body: JSON.stringify(payload)
    });

    if (!response.ok) throw new Error(\`API call failed: \${response.statusText}\`);
    const result = await response.json();
    
    await supabase.from('generations').update({
      provider_task_id: result.taskId || result.id,
      provider_request: payload,
      provider_response: result
    }).eq('id', generation.id);

    params.startPolling(generation.id);
    return generation.id;
  } catch (error) {
    await supabase.from('generations').update({ status: 'failed' }).eq('id', generation.id);
    throw error;
  }
}

async function getProviderApiKey(provider: string): Promise<string> {
  const { data, error } = await supabase.functions.invoke('get-api-key', {
    body: { provider }
  });
  if (error || !data?.apiKey) throw new Error('Failed to get API key');
  return data.apiKey;
}
`;
}

async function generateAllFiles() {
  console.log("üöÄ Fetching all 60 models from database...");
  
  const { data: models, error } = await supabase
    .from('ai_models')
    .select('*')
    .order('provider', { ascending: true })
    .order('model_name', { ascending: true });

  if (error || !models) {
    console.error("‚ùå Failed to fetch models:", error);
    process.exit(1);
  }

  console.log(`‚úÖ Found ${models.length} models\n`);

  const imports: string[] = [];
  const recordIdRegistry: string[] = [];
  const modelIdRegistry: string[] = [];

  for (const model of models) {
    const group = extractPrimaryGroup(model as AIModel);
    const fileName = sanitizeFileName(model.model_name);
    const filePath = path.join(process.cwd(), 'src/lib/models/locked', group, `${fileName}.ts`);
    
    // Create directory if doesn't exist
    const dirPath = path.dirname(filePath);
    if (!fs.existsSync(dirPath)) {
      fs.mkdirSync(dirPath, { recursive: true });
    }

    // Generate and write file
    const content = generateModelFileContent(model as AIModel);
    fs.writeFileSync(filePath, content);
    
    console.log(`‚úÖ Generated: src/lib/models/locked/${group}/${fileName}.ts`);

    // Build registry imports
    const varName = fileName.replace(/-/g, '_');
    imports.push(`import * as ${varName} from "./${group}/${fileName}";`);
    recordIdRegistry.push(`  "${model.record_id}": ${varName} as ModelModule,`);
    modelIdRegistry.push(`  "${model.id}": ${varName} as ModelModule,`);
  }

  // Generate registry file
  const registryContent = `/**
 * Model Registry - Central index of all isolated model files
 * Each model is completely independent with zero shared logic
 */

${imports.join('\n')}

interface ModelModule {
  MODEL_CONFIG: {
    modelId: string;
    recordId: string;
    modelName: string;
    provider: string;
    contentType: string;
    baseCreditCost: number;
    estimatedTimeSeconds: number;
    costMultipliers: any;
    apiEndpoint: string | null;
    payloadStructure: string;
    maxImages: number | null;
    defaultOutputs: number;
  };
  SCHEMA: any;
  validate: (inputs: Record<string, any>) => { valid: boolean; error?: string };
  preparePayload: (inputs: Record<string, any>) => Record<string, any>;
  calculateCost: (inputs: Record<string, any>) => number;
  execute: (params: any) => Promise<string>;
}

/**
 * Registry mapping record_ids to their modules
 * This is the primary lookup since record_id is unique
 */
export const RECORD_ID_REGISTRY: Record<string, ModelModule> = {
${recordIdRegistry.join('\n')}
};

/**
 * Registry mapping model IDs to their modules
 * Key: model.id (from database)
 * Value: Model module with SCHEMA, execute(), etc.
 */
export const MODEL_REGISTRY: Record<string, ModelModule> = {
${modelIdRegistry.join('\n')}
};

/**
 * Get model module by record_id (preferred) or model_id (fallback)
 */
export function getModelModule(recordId: string, modelId?: string): ModelModule | null {
  // Prefer record_id lookup (unique identifier)
  if (RECORD_ID_REGISTRY[recordId]) {
    return RECORD_ID_REGISTRY[recordId];
  }
  
  // Fallback to model_id if provided
  if (modelId && MODEL_REGISTRY[modelId]) {
    return MODEL_REGISTRY[modelId];
  }
  
  return null;
}

/**
 * Check if a model file exists
 */
export function modelFileExists(recordId: string, modelId?: string): boolean {
  return getModelModule(recordId, modelId) !== null;
}

/**
 * Get all available model record IDs
 */
export function getAvailableModelRecordIds(): string[] {
  return Object.keys(RECORD_ID_REGISTRY);
}

/**
 * Get all available model IDs
 */
export function getAvailableModelIds(): string[] {
  return Object.keys(MODEL_REGISTRY);
}
`;

  const registryPath = path.join(process.cwd(), 'src/lib/models/locked/index.ts');
  fs.writeFileSync(registryPath, registryContent);
  
  console.log(`\n‚úÖ Updated registry: src/lib/models/locked/index.ts`);
  console.log(`\nüéâ Successfully generated ${models.length} model files!`);
}

generateAllFiles().catch(console.error);
